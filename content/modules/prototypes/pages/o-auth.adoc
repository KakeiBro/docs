= Google OAuth 2.0

include::partial$google-oauth-2.adoc[]

== Google OAuth Setup

include::partial$google-oauth-setup.adoc[]

== Usage of APIs for authentication

include::partial$api-usage.adoc[]

== Project Rundown

include::partial$project-rundown.adoc[]

=== Illustrative Code

This is a really ad-hoc implementation that can help you understand how we should be 
using both the API and how the flows should work when trying to integrate with Google 
Auth:

[source, csharp]
----
using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    private static readonly string clientId = "YOUR_CLIENT_ID";
    private static readonly string clientSecret = "YOUR_CLIENT_SECRET";
    private static readonly string redirectUri = "http://localhost:5000/google-auth-callback";
    private static readonly string authorizationEndpoint = "https://accounts.google.com/o/oauth2/v2/auth";
    private static readonly string tokenEndpoint = "https://oauth2.googleapis.com/token";

    static async Task Main(string[] args)
    {
        // Step 1: Direct user to Google's authorization endpoint
        var authorizationUrl = $"{authorizationEndpoint}?client_id={clientId}" +
                               $"&redirect_uri={Uri.EscapeDataString(redirectUri)}" +
                               $"&response_type=code&scope=openid email profile";
        Console.WriteLine("Visit the following URL to authorize the app:");
        Console.WriteLine(authorizationUrl);

        // Step 2: User enters the authorization code
        Console.Write("\nEnter the authorization code: ");
        var authorizationCode = Console.ReadLine();

        // Step 3: Exchange authorization code for tokens
        var tokens = await GetTokensAsync(authorizationCode);
        Console.WriteLine("\nAccess Token: " + tokens.AccessToken);
        Console.WriteLine("Refresh Token: " + tokens.RefreshToken);
    }

    private static async Task<TokenResponse> GetTokensAsync(string authorizationCode)
    {
        using var httpClient = new HttpClient();

        var requestContent = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("code", authorizationCode),
            new KeyValuePair<string, string>("client_id", clientId),
            new KeyValuePair<string, string>("client_secret", clientSecret),
            new KeyValuePair<string, string>("redirect_uri", redirectUri),
            new KeyValuePair<string, string>("grant_type", "authorization_code"),
        });

        var response = await httpClient.PostAsync(tokenEndpoint, requestContent);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            throw new Exception($"Error fetching tokens: {response.StatusCode} {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<TokenResponse>(responseContent);
    }
}

// Helper class to parse token response
public class TokenResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public string TokenType { get; set; }
    public int ExpiresIn { get; set; }
    public string Scope { get; set; }
}
----

=== Folder Structure

We are skipping over architecture patterns since this is a prototype (at least for now), 
we are focusing on quickly trying out the ideas we have in mind, in short, this is 
a deliverable from a _Spike_ that concerns OAuth's capabilities in a web app integrated 
with .NET.

The structure for the solution closely resembles its physical folder structure:

```
- GoogleOAuthPrototype
|-- src
|   |-- GoogleOAuthPrototype.Application
|   |   |-- Constants
|   |   |-- Files
|   |   |   |-- client_secrets.json
|   |   |-- POCO
|   |   |-- Services
|-- test
|   |-- GoogleOAuthPrototype.Application.UnitTests
```

The `client_secrets.json` file is there for illustrative purposes since it will 
never be comitted to version control. But it should be here as a base line of the 
source of truth when it comes to connecting to the virtual application that is living 
at Google Cloud. The code has been adapted so that this file is neccesary to be there 
(you have to get the file manually through secure means), put it in the path, and 
that way the prototype will be able to boot up, consume the google credentials and 
work as intended. This is neccesary to avoid leaking sensitive information.

Besides that, folders are separated by technical concerns (this is not recommended for 
big projects), but since the prototype is so small, then it's fine for simplicity's 
sake alongside a clear pathway into component visualization when it comes to enumerating 
all that's needed in order to integrate with Google Auth.

== Cross-Cutting Concerns

=== Configurations and Security

include::partial$cross-cutting-concerns.adoc[]