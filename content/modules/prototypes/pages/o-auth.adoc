= Google OAuth 2.0

include::partial$google-oauth-2.adoc[]

== Google OAuth Setup

include::partial$google-oauth-setup.adoc[]

== Usage of APIs for authentication

include::partial$api-usage.adoc[]

== Project Rundown

include::partial$project-rundown.adoc[]

=== Illustrative Code

This is a really ad-hoc implementation that can help you understand how we should be 
using both the API and how the flows should work when trying to integrate with Google 
Auth:

[source, csharp]
----
using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

class Program
{
    private static readonly string clientId = "YOUR_CLIENT_ID";
    private static readonly string clientSecret = "YOUR_CLIENT_SECRET";
    private static readonly string redirectUri = "http://localhost:5000/google-auth-callback";
    private static readonly string authorizationEndpoint = "https://accounts.google.com/o/oauth2/v2/auth";
    private static readonly string tokenEndpoint = "https://oauth2.googleapis.com/token";

    static async Task Main(string[] args)
    {
        // Step 1: Direct user to Google's authorization endpoint
        var authorizationUrl = $"{authorizationEndpoint}?client_id={clientId}" +
                               $"&redirect_uri={Uri.EscapeDataString(redirectUri)}" +
                               $"&response_type=code&scope=openid email profile";
        Console.WriteLine("Visit the following URL to authorize the app:");
        Console.WriteLine(authorizationUrl);

        // Step 2: User enters the authorization code
        Console.Write("\nEnter the authorization code: ");
        var authorizationCode = Console.ReadLine();

        // Step 3: Exchange authorization code for tokens
        var tokens = await GetTokensAsync(authorizationCode);
        Console.WriteLine("\nAccess Token: " + tokens.AccessToken);
        Console.WriteLine("Refresh Token: " + tokens.RefreshToken);
    }

    private static async Task<TokenResponse> GetTokensAsync(string authorizationCode)
    {
        using var httpClient = new HttpClient();

        var requestContent = new FormUrlEncodedContent(new[]
        {
            new KeyValuePair<string, string>("code", authorizationCode),
            new KeyValuePair<string, string>("client_id", clientId),
            new KeyValuePair<string, string>("client_secret", clientSecret),
            new KeyValuePair<string, string>("redirect_uri", redirectUri),
            new KeyValuePair<string, string>("grant_type", "authorization_code"),
        });

        var response = await httpClient.PostAsync(tokenEndpoint, requestContent);

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            throw new Exception($"Error fetching tokens: {response.StatusCode} {errorContent}");
        }

        var responseContent = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<TokenResponse>(responseContent);
    }
}

// Helper class to parse token response
public class TokenResponse
{
    public string AccessToken { get; set; }
    public string RefreshToken { get; set; }
    public string TokenType { get; set; }
    public int ExpiresIn { get; set; }
    public string Scope { get; set; }
}
----

=== Folder Structure

We are skipping over architecture patterns since this is a prototype (at least for now), 
we are focusing on quickly trying out the ideas we have in mind, in short, this is 
a deliverable from a _Spike_ that concerns OAuth's capabilities in a web app integrated 
with .NET.

The structure for the solution closely resembles its physical folder structure:

```
- GoogleOAuthPrototype
|-- src
|   |-- GoogleOAuthPrototype.Application
|   |   |-- client_secrets.json
|-- test
|   |-- GoogleOAuthPrototype.Application.UnitTests
```

The `client_secrets.json` file is there for illustrative purposes since it will 
never be comitted to version control. But it should be here as a base line of the 
source of truth when it comes to connecting to the virtual application that is living 
at Google Cloud. The code has been adapted so that this file is neccesary to be there 
(you have to get the file manually through secure means), put it in the path, and 
that way the prototype will be able to boot up, consume the google credentials and 
work as intended. This is neccesary to avoid leaking sensitive information.

== Cross-Cutting Concerns

=== Configurations and Security

When it comes to one really important _CCC_ it is the fact that we need credentials 
from Google in order to hit their endpoints and then on behalf of a user start consuming 
their APIs.

It is due to this, that we have to establish an implementation that accounts for a secure 
way to hydrate the app with the data that only lives on a workstation, and is never 
uploaded to version control.

It was decided that in order to work with this, we have to download the 
`client_secrets.json` file, put it inside the `Application/Files` folder. If the 
files is for the right application registered in **Google Console**, then all flows 
should work correctly.

When putting an app into production we should definitely leverage the `IConfiguration` 
interface and its APIs alongside the usage of environmental variables in order to safely 
hydrate with the right set of credentials at build/deploy times, and not hard-coding it into 
the project.